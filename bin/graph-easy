#!/usr/bin/perl -w

use strict;
use Graph::Easy 0.55;
use Graph::Easy::Parser;

my $help_requested = 0;

# echo "[A]" | graph-easy  		# should work
# graph-easy				# need help
$help_requested = 1 if @ARGV == 0 && -t STDIN;

my $OUT = \*STDERR;
my $opt = get_options();

# error?
$help_requested = 1 if !ref($opt);

# no error and --help was specified
$help_requested = 2 if ref($opt) && $opt->{help} ne '';

my $copyright = "Graph::Easy v$Graph::Easy::VERSION  (c) by Tels 2004-2007.  "
	       ."Released under the GPL 2.0 or later.\n\n";

if ($help_requested > 0)
  {
  print $copyright;
  require Pod::Usage;
  if ($help_requested > 1 && $Pod::Usage::VERSION < 1.35)
    {
    # The way old Pod::Usage executes "perldoc" might fail:
    system('perldoc', $0);
    exit 2;
    }
  Pod::Usage::pod2usage( { -exitval => 2, -verbose => $help_requested } ); 
  }

my $verbose = $opt->{verbose};

print $OUT $copyright if $verbose;

#############################################################################
# Create the parser object

my $parser_class = 'Graph::Easy::Parser';
if ($opt->{from} eq 'graphviz')
  {
  require Graph::Easy::Parser::Graphviz;
  $parser_class = 'Graph::Easy::Parser::Graphviz';
  }
elsif ($opt->{from} =~ /^(vcg|gdl)\z/)
  {
  require Graph::Easy::Parser::VCG;
  $parser_class = 'Graph::Easy::Parser::VCG';
  }

print $OUT "Creating $parser_class object.\n" if $verbose;

my $parser = $parser_class->new( debug => $opt->{debug} );

#############################################################################
# parse the input file

print $OUT "Parsing input in $opt->{from} from $opt->{inputname}.\n" if $verbose;

my $graph = $parser->from_file($opt->{input});

my $error = '';
$error = $parser->error() if !$graph || $parser->error();
$error = $graph->error() if $graph && $graph->error();

die ("Parser error: " . $error) if $error;

#############################################################################
# Generate the wanted output format and write it to the output:

if (! $opt->{parse})
  {
  my $method = 'as_' . $opt->{as} . '_file';
  if ($verbose)
    {
    if ($opt->{outputname} =~ /\.png\z/)
      {
      print $OUT "Piping output to 'dot -Tpng -o \"$opt->{outputname}\"'.\n";
      }
    else
      {
      print $OUT "Writing output as $opt->{as} to $opt->{outputname}.\n";
      }
    }

  $graph->timeout(abs($opt->{timeout} || 120));
  my $FILE = $opt->{output};
  print $FILE $graph->$method();

  print $OUT "Everything done. Have fun!\n\n" if $verbose;
  }

#############################################################################
# Everything done

#############################################################################
#############################################################################

sub get_options
  {
  # set the defaults
  my $opt = {
    input => undef,
    output => undef,
    as => '',
    from => 'txt',
    help => '',
    as_ascii => '',
    as_boxart => '',
    as_html => '',
    as_svg => '',
    as_graphviz => '',
    as_txt => '',
    as_png => '',
    as_vcg => '',
    as_gdl => '',
    debug => 0,
    from_txt => '',
    from_graphviz => '',
    verbose => 0,
    parse => 0,
    timeout => 120,
  };
  # map the output format to the method to generate the output:
  my $formats = {
    html => 'html',
    txt => 'ascii',
    svg => 'svg',
    png => 'graphviz',
    dot => 'graphviz',
    vcg => 'vcg',
    gdl => 'gdl',
  };

  # do we have some options?
  if (@ARGV > 0)
    {
    require Getopt::Long;

    my $rc = Getopt::Long::GetOptions (
	"input=s" => \$opt->{input},
	"output=s" => \$opt->{output},
	"as=s" => \$opt->{as},
	"from=s" => \$opt->{from},
	"help|?" => \$opt->{help},
	"verbose" => \$opt->{verbose},
	"debug=i" => \$opt->{debug},
	"parse" => \$opt->{parse},
	"as_ascii|ascii" => \$opt->{as_ascii},
	"as_html|html" => \$opt->{as_html},
	"as_svg|svg" => \$opt->{as_svg},
	"as_png|png" => \$opt->{as_png},
	"as_txt|txt" => \$opt->{as_txt},
	"as_vcg|vcg" => \$opt->{as_vcg},
	"as_gdl|gdl" => \$opt->{as_gdl},
	"as_graphviz|graphviz|as_dot|dot" => \$opt->{as_graphviz},
	"as_boxart|boxart" => \$opt->{as_boxart},
	"timeout=i" => \$opt->{timeout},
	"from_txt" => \$opt->{from_txt},
	"from_graphviz" => \$opt->{from_graphviz},
	);
    return unless $rc;
    }

  # allow "as=dot" for easier usage:
  $opt->{as} = 'graphviz' if $opt->{as} eq 'dot';

  # if there areguments left, they are input and possible output
  $opt->{input} = shift @ARGV if @ARGV;
  $opt->{output} = shift @ARGV if @ARGV;

  if (!defined $opt->{input})
    {
    $opt->{input} = \*STDIN;
    $opt->{inputname} = 'STDIN';
    }
  else 
   {
   $opt->{inputname} = $opt->{input};
   }
 
  # This code gets confused if the user specified multiple options. Not much
  # can be done about that except whack the user with something heavy.
  for my $format (qw/ascii boxart html svg txt graphviz png vcg gdl/)
    {
    $opt->{as} = $format if $opt->{"as_$format"};
    delete $opt->{"as_$format"};
    }

  if ($opt->{as} eq 'png')
    {
    $opt->{output} = $opt->{input};
    # per default output it to graph.png
    $opt->{output} = 'graph.txt' if ref($opt->{input});
    $opt->{output} =~ s/\.(txt|dot|vcg|gdl)\z//;
    $opt->{output} .= '.' . $opt->{as};			# example.txt => example.png
    }
  if (!defined $opt->{output})
    {
    $opt->{outputname} = 'STDOUT';
    $opt->{output} = \*STDOUT;
    # default to ASCII if nothing is know
    $opt->{as} = 'ascii' if $opt->{as} eq '';
    }
  else
    {
    my $file = $opt->{output};
    $opt->{outputname} = $opt->{output};
    if ($opt->{as} eq '')
      {
      $opt->{as} = 'ascii';		# default
      $opt->{as} = $formats->{$1} if $file =~ /\.(html|svg|txt|dot|png|vcg|gdl)\z/;
      }
    $opt->{output} = undef;
    if ($opt->{as} ne 'png')
      {
      # do not clobber the output file if we cannot read the input
      return unless ref $opt->{input} || -R $opt->{input};

      open $opt->{output}, ">$file" or die ("Cannot write to $file: $!");
      }
    else
      {
      # open a pipe to dot
      my $file_save = $file;
      $file_save =~ s/["'\|;]//g;	# remove potentially unsafe characters
      open $opt->{output}, "|dot -Tpng -o \"$file_save\"" or die ("Cannot open pipe to dot: $!");
      }
    }
    
  if ($opt->{as} ne 'png')
    {
    binmode ($opt->{output}, ':utf8') or die ("Cannot do binmode(output,':utf8')");
    }
  else
    {
    $opt->{as} = 'graphviz';
    }

  for my $format (qw/txt graphviz dot vcg gdl/)
    {
    $opt->{from} = $format if $opt->{"from_$format"};
    delete $opt->{"from_$format"};
    }
  $opt->{from} = 'graphviz' if $opt->{from} eq 'dot';

  $opt;
  }

__END__

=pod

=head1 NAME

graph-easy - render/convert graphs in/from various formats

=head1 SYNOPSIS

Convert between graph formats and layout/render graphs:

	graph-easy [options] [inputfile [outputfile]]

	echo "[ Bonn ] - car -> [ Berlin ]" | graph-easy
	graph-easy --input=graph.dot --as_ascii
	graph-easy --html --output=graph.html graph.txt
	graph-easy graph.txt graph.svg
	graph-easy graph.txt --as_dot | dot -Tpng -o graph.png
	graph-easy graph.txt --as_png
	graph-easy graph.vcg --as_dot
	graph-easy graph.dot --gdl

=head1 ARGUMENTS

=over 10

=item --help

Print the full documentation, not just a short overview.

=item --input

Specify the input file name. Example:

	graph-easy --input=input.txt

The format of the input will be detected automatically, but you
can override this detection with L<--from>.

=item --output

Specify the output file name. Example:

	graph-easy --output=output.txt input.txt

=item --as

Specify the output format. Example:

	graph-easy --as=ascii input.txt

Valid formats are:

	ascii
	boxart
	html
	svg
	graphviz	the DOT language
	dot		an alias for "graphviz"
	txt		Graph::Easy text
	vcg		VCG (a subset of GDL) text
	gdl		GDL (Graph Description Language) text
	png		a PNG file rendered via "dot"

If unspecified, the default format will be determined by the output
filename extension, and is C<ascii>, if the output filename was not
set.

Note that you can also use B<ONE> argument of the form C<--as_ascii>,
C<--as_svg> and so on.

=item --from

Specify the input format. Valid formats are:

	graphviz	the DOT language
	txt		Graph::Easy text
	vcg		VCG text
	gdl		GDL (Graph Description Language) text

If not specified, the input format is auto-detected.

Note that you can also use B<ONE> argument of the form L<--from_graphviz>
or L<--from_txt> instead of C<--from>.

=item --verbose

Write info regarding the conversion process to STDERR.

=item --debug=N

Write debugging info to STDERR. Warning, this can create huge amounts
of hard-to-understand output!

Example:

	graph-easy input.txt --output=test.html --debug=1

=item --parse

When true, will only parse the input file and not output anything.
This is usefull in combination with C<--debug=1>.

Example:

	graph-easy input.txt --parse --debug=1

=item --timeout

Set the timeout B<in seconds> for the layouter. If the layout does not
finish in this time, it will be aborted.

Example:

	graph-easy input.txt --timeout=500

This option is mainly intended for things that are routed through
the layouter of Graph::Easy, because this layouter can sometimes
get stuck and use a lot of time. Simple conversions between
the different graph text formats are still subject to the set
timeout, but this conversion usually finishes in way under one
second.

=back

=head1 DESCRIPTION

C<graph-easy> reads a description of a graph (a connected network of
nodes and edges, not a pie chart :-) and then convert this to the desired
output format.

By default, the input will be read from STDIN, and the output will go to
STDOUT. The input is expected to be exencoded in UTF-8, the output will
also be UTF-8.

It understands the following formats as input:

	Graph::Easy	http://bloodgate.com/perl/graph/manual/
	DOT		http://www.graphviz.org/
	VCG		http://rw4.cs.uni-sb.de/~sander/html/gsvcg1.html
	GDL		http://www.aisee.com/

The formats are automatically detected, regardless of the input file name,
but you can also explicitely declare your input to be in one specific
format.

The output can either be a dump of the graph in one of the input formats
(Graph::Easy, Graphviz, VCG/GDL), or a layout (rendering) of the graph in
one of the following output formats implemented by C<Graph::Easy>:

	HTML	SVG	ASCII	BOXART

As a shortcut, you can also specify the output format as 'png', this will
cause C<graph-easy> to pipe the input in graphviz format to dot to create a
PNG file in one step. The following two examples are equivalent:

	graph-easy graph.txt --as_dot | dot -Tpng -o graph.png
	graph-easy graph.txt --as_png

X<svg>
X<html>
X<ascii>
X<boxart>
X<png>
X<dot>
X<graphviz>
X<vcg>
X<gdl>
X<graph description language>
X<unicode>

=head1 EXAMPLES

=head2 ASCII output

	echo "[ Bonn ] -- car --> [ Berlin ], [ Ulm ]" | graph-easy --as=ascii

	+--------+  car   +-----+
	|  Bonn  | -----> | Ulm |
	+--------+        +-----+
	  |
	  | car
	  v
	+--------+
	| Berlin |
	+--------+

=head2 Graphviz example output

	echo "[ Bonn ] -- car --> [ Berlin ], [ Ulm ]" | graph-easy --as=dot
	digraph GRAPH_0 {
	
	  edge [ arrowhead=open ];
	  graph [ rankdir=LR ];
	  node [
	    fontsize=11,
	    fillcolor=white,
	    style=filled,
	    shape=box ];
	
	  Bonn -> Ulm [ label=car ]
	  Bonn -> Berlin [ label=car ]
	
	}

=head3 VCG example output:

	echo "[ Bonn ] -- car --> [ Berlin ], [ Ulm ]" | graph-easy --as=vcg
	graph: {
	  title: "Untitled graph"
	
	  node: { title: "Berlin" }
	  node: { title: "Bonn" }
	  node: { title: "Ulm" }
	
	  edge:  { label: "car" sourcename: "Bonn" targetname: "Ulm" }
	  edge:  { label: "car" sourcename: "Bonn" targetname: "Berlin" }
	
	}

=head3 GDL example output:

GDL (Graph Description Language) is a superset of VCG, and thus the output will
look almost the same as VCG:

	echo "[ Bonn ] -- car --> [ Berlin ], [ Ulm ]" | graph-easy --as=gdl
	graph: {
	  title: "Untitled graph"
	
	  node: { title: "Berlin" }
	  node: { title: "Bonn" }
	  node: { title: "Ulm" }
	
	  edge:  { label: "car" source: "Bonn" target: "Ulm" }
	  edge:  { label: "car" source: "Bonn" target: "Berlin" }

	}	

=head1 LICENSE

This library is free software; you can redistribute it and/or modify
it under the terms of the GPL.

See the LICENSE file of Graph::Easy for a copy of the GPL.

This product includes color specifications and designs developed by Cynthia
Brewer (http://colorbrewer.org/). See the LICENSE file for the full license
text that applies to these color schemes.
X<gpl>
X<apache-style>
X<cynthia>
X<brewer>
X<colorscheme>
X<license>

=head1 AUTHOR

Copyright (C) 2004 - 2007 by Tels L<http://bloodgate.com>

=head1 SEE ALSO

L<Graph::Easy>

=cut

