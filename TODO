Graph-Easy
==========

See Graph::Easy under LIMITATIONS for some hot topics.

In addition:

Parser:

* deal with " -> [ node ], [node2], [node3]"
* parse nested graphs
* support for node splitting ala:

    "[ A ] | [ B | C ] || [ D | E ]"

* support for attribute lists on autosplit nodes ala:

    "[ A || B | C ] { background: red,blue,green; }"

* Nodes with both "|" and "\|" in their name are parsed wrongly

Output:

* write as_box(): output with box-drawing chars (unicode or iso)
* support different edge starting point styles ala:

  ----->  |----->  o----->  +----->  *----->  >>----->

* as_txt(): output of node clusters is not optimal
* as_ascii(): output group borders and labels
* as_ascii(): node clusters need adjoining borders collapsed together
  +---++---+      +---+---+
  | A || B | vs.  | A | B |  (that als means A needs to be width-1!)
  +---++---+      +---+---+
* as_ascii(): edges with multiple cells and a style other than "--" will
		get their style only for one cell (should be all cells)
* as_ascii(), as_html(): grow edges to be seemless
* as_html: node clusters have spacings between nodes:
           The spacing comes from the filler cells to make groups
	   work - argl!
* as_html(): output group labels
* as_html(): edges are borked in Opera, the table cell is not big enough
	     to hold them (*sigh*)
* as_html: for shape: circle, find out real dimensions by splitting
  the label into lines (instead of taking the overall label lenght
  as the in-width) (see t/fun/0030.txt as an example of overwide
  circles)
* as_html(): add a class "link" to generated links (so they can be styled
             differently)
* better support for different shapes (circle, box, rounded, polygon etc)
  in HTML/ASCII/Graphviz

Layout:

* Use the seed to generate randomized layouts
* for u-shaped edges, the starting cell must be EDGE_START_E etc, not just
  EDGE_HOR or EDGE_VER
* u-shaped path's could be shorter by one cell (when we create an edge cell
  that is both an edge and an endpoint at the same time)
* allow user to specifiy prefered direction of edges, as well as
  relatively placed nodes (in position relativ to another node)
* allow user to specify 
    direction: (up|down|left|right|north|south|west|east|0|90|180|270|360);
  to create default direction of edges
* rewrite high-level code
* _trace_path(): paths with one bend need the correct corner-piece instead
  of EDGE_CROSS
* code to trace U-shaped paths can result in an endless loop
* _trace_path(): use A* algorithmn as last resort to find path
* make nodes occupy more than one cell (for making very wide/very high nodes
  fit better, as well as allowing more than 4 edges in/out of one node)
* echo "[B] [A] -> [B]" | examples/as_ascii
  +---+     +---+
  | B | <-- | A |
  +---+     +---+
  That should actually be:
  +---+     +---+
  | A | --> | B |
  +---+     +---+

Optimizer:

* write an optimizer, that can optimize an already found layout
* less memory: store border and edge styles as ints instead of "solid" etc
* optimize attribute():

%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 52.1   0.440  0.440 130300   0.0000 0.0000  Graph::Easy::attribute
 39.3   0.332  0.818  44000   0.0000 0.0000  Graph::Easy::Node::attribute
 17.5   0.148  1.067   8800   0.0000 0.0001  Graph::Easy::Node::as_html
 13.1   0.111  1.217    100   0.0011 0.0122  Graph::Easy::as_html
 7.94   0.067  0.067  52600   0.0000 0.0000  Graph::Easy::Node::class
 7.58   0.064  0.370   8800   0.0000 0.0000  Graph::Easy::Node::title
 5.92   0.050  0.099     24   0.0021 0.0041  Graph::Easy::BEGIN
 2.37   0.020  0.129      5   0.0040 0.0258  main::BEGIN
 2.01   0.017  0.016   1400   0.0000 0.0000  Graph::Easy::Edge::Cell::_content
 1.90   0.016  0.143   7000   0.0000 0.0000  Graph::Easy::Edge::Cell::attribute
 1.90   0.016  0.218   1400   0.0000 0.0002  Graph::Easy::Edge::Cell::as_html

Manual:

* finish the HTML conversion (Graph::Easy::Pod2HTML)
* write the actual manual text (in chapters)

Misc:

* Add our format to Graph::ReadWrite
* add test for bug "my $ox = $x - $self->{dx};" vs $x + $self->{dx}
